# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sgjESxQXGvWEeFAFLl3PpdKrdLyzoT-a
"""

import pandas as pd
import numpy as np

from google.colab import files
uploaded = files.upload()

df = pd.read_csv('water_potability.csv')  # Use the direct file name without 'data/' folder
print(df.head())

print("üîç First 5 rows of data:")
print(df.head())

print("\nüìä Dataset Info:")
print(df.info())

print("\n‚ùì Missing Values:")
print(df.isnull().sum())

print("\nüìà Statistical Summary:")
print(df.describe())

missing_values = df.isnull().sum()
print("Missing Values in each column:")
print(missing_values)

df = df.fillna(df.median())

print("\nData Types of each column:")
print(df.dtypes)

print("\nData after filling missing values:")
print(df.head())

import seaborn as sns
import matplotlib.pyplot as plt

df.hist(bins=20, figsize=(10, 10))
plt.suptitle('Feature Distributions')
plt.show()

sns.boxplot(x='Potability', y='ph', data=df)
plt.title('pH vs Potability')
plt.show()

plt.figure(figsize=(10, 8))
sns.heatmap(df.corr(), annot=True, cmap='coolwarm', fmt='.2f')
plt.title('Correlation Heatmap')
plt.show()

plt.figure(figsize=(12, 8))
sns.boxplot(data=df)
plt.title('Boxplot of All Features (Outliers)')
plt.show()

!pip install xgboost

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report
import xgboost as xgb

X = df.drop('Potability', axis=1)  # All columns except 'Potability'
y = df['Potability']  # Target column

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

log_reg = LogisticRegression(max_iter=200)
log_reg.fit(X_train_scaled, y_train)
y_pred_log_reg = log_reg.predict(X_test_scaled)

rf_clf = RandomForestClassifier(n_estimators=100, random_state=42)
rf_clf.fit(X_train, y_train)
y_pred_rf = rf_clf.predict(X_test)

# Step 6: Train XGBoost Classifier
xgb_clf = xgb.XGBClassifier(use_label_encoder=False, eval_metric='logloss')
xgb_clf.fit(X_train, y_train)
y_pred_xgb = xgb_clf.predict(X_test)

print("\nLogistic Regression Classification Report:")
print(classification_report(y_test, y_pred_log_reg))

# Random Forest Evaluation
print("\nRandom Forest Classification Report:")
print(classification_report(y_test, y_pred_rf))

# XGBoost Evaluation
print("\nXGBoost Classification Report:")
print(classification_report(y_test, y_pred_xgb))

# Step 5: Alert System
def check_water_quality(input_data):
    """
    Function to predict water quality and send an alert if unsafe.

    Args:
    input_data: list of feature values (e.g., pH, Hardness, Sulfate, etc.)

    Returns:
    str: Alert message (safe or unsafe)
    """
    # Transform the input data to match the model's training format
    input_data_scaled = scaler.transform([input_data])  # Standardize the input data

    # Predict using the best model (we'll assume Random Forest is the best here)
    prediction = rf_clf.predict(input_data_scaled)[0]  # Returns 0 or 1

    if prediction == 0:
        return "üö® ALERT: Water is unsafe! Immediate action needed!"
    else:
        return "‚úÖ Water is safe for consumption."

# Example Usage: (Replace with actual input data)
input_data_example = [7.5, 200, 5000, 5.2, 300, 450, 12, 50, 2]  # Example values for features
alert = check_water_quality(input_data_example)
print(alert)

!pip install streamlit

import streamlit as st
import pandas as pd
import xgboost as xgb
from sklearn.preprocessing import StandardScaler

# Load model and scaler (same as in the notebook)
# Load your pre-trained model and scaler here

# Function for checking water quality
def check_water_quality(input_data):
    input_data_scaled = scaler.transform([input_data])
    prediction = rf_clf.predict(input_data_scaled)[0]
    if prediction == 0:
        return "üö® ALERT: Water is unsafe! Immediate action needed!"
    else:
        return "‚úÖ Water is safe for consumption."

# Streamlit UI
st.title("Water Quality Prediction & Alert System")
st.write("Enter the following parameters to predict water quality:")

# Input fields for each feature (example: pH, Hardness, Sulfate, etc.)
pH = st.number_input("pH Level", min_value=5.0, max_value=9.0, value=7.0)
Hardness = st.number_input("Hardness", min_value=100, max_value=500, value=200)
Solids = st.number_input("Solids", min_value=500, max_value=50000, value=10000)
Chloramines = st.number_input("Chloramines", min_value=0.5, max_value=10.0, value=5.0)
Sulfate = st.number_input("Sulfate", min_value=100, max_value=500, value=200)
Conductivity = st.number_input("Conductivity", min_value=100, max_value=800, value=400)
Organic_carbon = st.number_input("Organic Carbon", min_value=2, max_value=30, value=10)
Trihalomethanes = st.number_input("Trihalomethanes", min_value=10, max_value=120, value=60)
Turbidity = st.number_input("Turbidity", min_value=1, max_value=7, value=3)

# Prediction button
if st.button("Check Water Quality"):
    input_data = [pH, Hardness, Solids, Chloramines, Sulfate, Conductivity, Organic_carbon, Trihalomethanes, Turbidity]
    alert_message = check_water_quality(input_data)
    st.write(alert_message)

!streamlit run water_quality_dashboard.py